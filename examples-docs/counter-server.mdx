---
title: Counter Server Example
description: 'Build a simple stateful counter MCP server'
---

# Counter Server Example

Learn the fundamentals of Vulcan by building a simple counter server with state management.

## What You'll Build

A stateful MCP server that maintains a counter and provides tools to:
- Increment the counter
- Decrement the counter
- Get the current value
- Reset to zero

## Complete Code

Here's the complete implementation:

```rust src/main.rs
use std::sync::Arc;
use tokio::sync::Mutex;
use vulcan::{
    tool, tool_router, tool_handler,
    ServerHandler, ErrorData,
    model::*,
    handler::server::tool::ToolRouter,
    service::ServiceExt,
};

#[derive(Clone)]
pub struct Counter {
    counter: Arc<Mutex<i32>>,
    tool_router: ToolRouter<Self>,
}

#[tool_router]
impl Counter {
    fn new() -> Self {
        Self {
            counter: Arc::new(Mutex::new(0)),
            tool_router: Self::tool_router(),
        }
    }

    #[tool(description = "Increment the counter by 1")]
    async fn increment(&self) -> Result<i32, ErrorData> {
        let mut counter = self.counter.lock().await;
        *counter += 1;
        Ok(*counter)
    }

    #[tool(description = "Decrement the counter by 1")]
    async fn decrement(&self) -> Result<i32, ErrorData> {
        let mut counter = self.counter.lock().await;
        *counter -= 1;
        Ok(*counter)
    }

    #[tool(description = "Get the current counter value")]
    async fn get(&self) -> Result<i32, ErrorData> {
        Ok(*self.counter.lock().await)
    }

    #[tool(description = "Reset the counter to zero")]
    async fn reset(&self) -> Result<i32, ErrorData> {
        let mut counter = self.counter.lock().await;
        *counter = 0;
        Ok(*counter)
    }

    #[tool(description = "Add a specific value to the counter")]
    async fn add(&self, value: i32) -> Result<i32, ErrorData> {
        let mut counter = self.counter.lock().await;
        *counter += value;
        Ok(*counter)
    }
}

#[tool_handler]
impl ServerHandler for Counter {
    fn get_info(&self) -> ServerInfo {
        ServerInfo {
            protocol_version: ProtocolVersion::V_2024_11_05,
            capabilities: ServerCapabilities::builder()
                .enable_tools()
                .build(),
            server_info: Implementation {
                name: "counter-server".to_string(),
                version: "1.0.0".to_string(),
                ..Default::default()
            },
            instructions: Some(
                "A simple counter server demonstrating stateful MCP tools.".to_string()
            ),
        }
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let server = Counter::new();
    server.serve((tokio::io::stdin(), tokio::io::stdout())).await?;
    Ok(())
}
```

## Breaking It Down

### 1. Server Struct

```rust
#[derive(Clone)]
pub struct Counter {
    counter: Arc<Mutex<i32>>,      // Shared state
    tool_router: ToolRouter<Self>,  // Required for tool dispatch
}
```

**Key points:**
- `Clone` is required for the server to be clonable
- `Arc<Mutex<T>>` provides thread-safe shared state
- `tool_router` is auto-generated by the `#[tool_router]` macro

### 2. Tool Implementation

```rust
#[tool_router]
impl Counter {
    fn new() -> Self {
        Self {
            counter: Arc::new(Mutex::new(0)),
            tool_router: Self::tool_router(),  // Generated by macro
        }
    }

    #[tool(description = "Increment the counter by 1")]
    async fn increment(&self) -> Result<i32, ErrorData> {
        let mut counter = self.counter.lock().await;
        *counter += 1;
        Ok(*counter)
    }
}
```

**Key points:**
- `#[tool_router]` generates the tool router
- Each `#[tool]` method becomes an MCP tool
- Return values are auto-serialized to JSON
- State is accessed via `Arc<Mutex<T>>`

### 3. ServerHandler Implementation

```rust
#[tool_handler]
impl ServerHandler for Counter {
    fn get_info(&self) -> ServerInfo {
        ServerInfo {
            capabilities: ServerCapabilities::builder()
                .enable_tools()
                .build(),
            server_info: Implementation {
                name: "counter-server".to_string(),
                version: "1.0.0".to_string(),
                ..Default::default()
            },
            instructions: Some("A simple counter server.".to_string()),
        }
    }
}
```

**Key points:**
- `#[tool_handler]` auto-implements `list_tools()` and `call_tool()`
- You only implement `get_info()`
- Enable capabilities with the builder pattern

## Running the Server

### Build

```bash
cargo build --release --features server,transport-io
```

### Test Locally

Create a test client:

```rust examples/test_client.rs
use vulcan::{service::ServiceExt, transport::duplex};
use vulcan::model::CallToolRequestParam;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Create in-process transport
    let (client_transport, server_transport) = duplex();

    // Spawn server
    tokio::spawn(async move {
        Counter::new().serve(server_transport).await.ok();
    });

    // Connect client
    let client = ().serve(client_transport).await?;

    // Test increment
    let result = client.call_tool(CallToolRequestParam {
        name: "increment".into(),
        arguments: None,
    }).await?;

    println!("Counter: {:?}", result);

    Ok(())
}
```

### Claude Desktop Integration

Add to `claude_desktop_config.json`:

<Tabs>
  <Tab title="macOS">
    ```json
    {
      "mcpServers": {
        "counter": {
          "command": "/path/to/target/release/counter-server"
        }
      }
    }
    ```
  </Tab>

  <Tab title="Windows">
    ```json
    {
      "mcpServers": {
        "counter": {
          "command": "C:\\path\\to\\target\\release\\counter-server.exe"
        }
      }
    }
    ```
  </Tab>
</Tabs>

## Variations

### With Validation

Add input validation:

```rust
#[tool(description = "Add a value (max Â±100)")]
async fn add(&self, value: i32) -> Result<i32, ErrorData> {
    if value.abs() > 100 {
        return Err(ErrorData::invalid_input(
            "Value must be between -100 and 100"
        ));
    }

    let mut counter = self.counter.lock().await;
    *counter += value;
    Ok(*counter)
}
```

### With Limits

Prevent overflow:

```rust
#[tool(description = "Increment with overflow protection")]
async fn increment(&self) -> Result<i32, ErrorData> {
    let mut counter = self.counter.lock().await;

    if *counter == i32::MAX {
        return Err(ErrorData::invalid_input(
            "Counter at maximum value"
        ));
    }

    *counter += 1;
    Ok(*counter)
}
```

### With History

Track operations:

```rust
#[derive(Clone)]
pub struct Counter {
    counter: Arc<Mutex<i32>>,
    history: Arc<Mutex<Vec<String>>>,
    tool_router: ToolRouter<Self>,
}

#[tool(description = "Get operation history")]
async fn history(&self) -> Result<Vec<String>, ErrorData> {
    Ok(self.history.lock().await.clone())
}

#[tool(description = "Increment and log")]
async fn increment(&self) -> Result<i32, ErrorData> {
    let mut counter = self.counter.lock().await;
    let mut history = self.history.lock().await;

    *counter += 1;
    history.push(format!("Incremented to {}", *counter));

    Ok(*counter)
}
```

## Testing

### Unit Test

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_increment() {
        let counter = Counter::new();

        let result1 = counter.increment().await.unwrap();
        assert_eq!(result1, 1);

        let result2 = counter.increment().await.unwrap();
        assert_eq!(result2, 2);
    }

    #[tokio::test]
    async fn test_add() {
        let counter = Counter::new();

        let result = counter.add(5).await.unwrap();
        assert_eq!(result, 5);

        let result = counter.add(-3).await.unwrap();
        assert_eq!(result, 2);
    }

    #[tokio::test]
    async fn test_reset() {
        let counter = Counter::new();

        counter.add(10).await.unwrap();
        let result = counter.reset().await.unwrap();
        assert_eq!(result, 0);
    }
}
```

### Integration Test

```rust
#[tokio::test]
async fn test_counter_integration() {
    use vulcan::transport::duplex;

    let (client_transport, server_transport) = duplex();

    tokio::spawn(async move {
        Counter::new().serve(server_transport).await.ok();
    });

    let client = ().serve(client_transport).await.unwrap();

    // Increment 3 times
    for _ in 0..3 {
        client.call_tool(CallToolRequestParam {
            name: "increment".into(),
            arguments: None,
        }).await.unwrap();
    }

    // Get value
    let result = client.call_tool(CallToolRequestParam {
        name: "get".into(),
        arguments: None,
    }).await.unwrap();

    // Verify
    if let Some(Content::Text(text)) = result.content.first() {
        let value: i32 = text.text.parse().unwrap();
        assert_eq!(value, 3);
    }
}
```

## Key Takeaways

<AccordionGroup>
  <Accordion title="State Management">
    Use `Arc<Mutex<T>>` for thread-safe shared state:

    ```rust
    counter: Arc<Mutex<i32>>
    ```

    Always `await` when locking:

    ```rust
    let mut counter = self.counter.lock().await;
    ```
  </Accordion>

  <Accordion title="Tool Macros">
    Three macros work together:

    1. `#[tool_router]` - Generates the router
    2. `#[tool]` - Marks methods as tools
    3. `#[tool_handler]` - Auto-implements ServerHandler
  </Accordion>

  <Accordion title="Auto-Serialization">
    Return your types directly:

    ```rust
    async fn get(&self) -> Result<i32, ErrorData> {
        Ok(*self.counter.lock().await)
    }
    ```

    Vulcan handles JSON conversion automatically!
  </Accordion>

  <Accordion title="Error Handling">
    Use ergonomic error constructors:

    ```rust
    Err(ErrorData::invalid_input("Value too large"))
    ```

    Much cleaner than verbose error formatting!
  </Accordion>
</AccordionGroup>

## Next Steps

<CardGroup cols={2}>
  <Card title="Middleware Example" icon="layer-group" href="/examples-docs/middleware">
    Add logging and metrics
  </Card>
  <Card title="Advanced State" icon="database" href="/examples-docs/ports-adapters">
    Ports and adapters pattern
  </Card>
  <Card title="Testing Guide" icon="vial" href="/guides/testing">
    Write comprehensive tests
  </Card>
  <Card title="Deployment" icon="rocket" href="/guides/deployment">
    Deploy to production
  </Card>
</CardGroup>
