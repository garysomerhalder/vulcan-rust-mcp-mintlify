---
title: Building a Server
description: 'Complete guide to building MCP servers with Vulcan'
---

# Building an MCP Server

Learn how to build production-ready MCP servers with Vulcan's zero-boilerplate API.

## Overview

Building an MCP server with Vulcan involves three main steps:

<Steps>
  <Step title="Define Your Server Struct">
    Create a struct that holds your server state and tool router
  </Step>
  <Step title="Implement Tools">
    Use `#[tool]` macro on async methods to define MCP tools
  </Step>
  <Step title="Implement ServerHandler">
    Use `#[tool_handler]` macro to auto-implement the handler trait
  </Step>
  <Step title="Serve">
    Call `.serve(transport)` to start your server
  </Step>
</Steps>

## Quick Example

Here's a complete MCP server in ~30 lines:

```rust
use std::sync::Arc;
use tokio::sync::Mutex;
use vulcan::{
    tool, tool_router, tool_handler, ServerHandler,
    model::*, ErrorData,
    handler::server::tool::ToolRouter,
    service::ServiceExt,
};

#[derive(Clone)]
pub struct Counter {
    counter: Arc<Mutex<i32>>,
    tool_router: ToolRouter<Self>,
}

#[tool_router]
impl Counter {
    fn new() -> Self {
        Self {
            counter: Arc::new(Mutex::new(0)),
            tool_router: Self::tool_router(),
        }
    }

    #[tool(description = "Increment the counter by 1")]
    async fn increment(&self) -> Result<i32, ErrorData> {
        let mut counter = self.counter.lock().await;
        *counter += 1;
        Ok(*counter)
    }

    #[tool(description = "Get current value")]
    async fn get(&self) -> Result<i32, ErrorData> {
        Ok(*self.counter.lock().await)
    }
}

#[tool_handler]
impl ServerHandler for Counter {
    fn get_info(&self) -> ServerInfo {
        ServerInfo {
            capabilities: ServerCapabilities::builder()
                .enable_tools()
                .build(),
            server_info: Implementation {
                name: "counter-server".to_string(),
                version: "1.0.0".to_string(),
                ..Default::default()
            },
            ..Default::default()
        }
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    Counter::new().serve((tokio::io::stdin(), tokio::io::stdout())).await?;
    Ok(())
}
```

That's it! No manual JSON-RPC, no schema generation, no boilerplate.

## Step-by-Step Guide

### 1. Project Setup

Create a new Rust project:

```bash
cargo new my-mcp-server
cd my-mcp-server
```

Add dependencies to `Cargo.toml`:

```toml Cargo.toml
[dependencies]
vulcan = { version = "0.1", features = ["server", "macros", "transport-io"] }
tokio = { version = "1", features = ["full"] }
serde = { version = "1", features = ["derive"] }
schemars = "0.8"
```

### 2. Define Your Server Struct

Create a struct to hold your server state:

```rust
use vulcan::handler::server::tool::ToolRouter;
use std::sync::Arc;
use tokio::sync::Mutex;

#[derive(Clone)]
pub struct MyServer {
    // Your state here
    data: Arc<Mutex<HashMap<String, String>>>,

    // Required: tool router
    tool_router: ToolRouter<Self>,
}
```

<Note>
The `tool_router` field is **required**. It's generated by the `#[tool_router]` macro and handles tool dispatch.
</Note>

### 3. Implement Tools

Use the `#[tool_router]` and `#[tool]` macros to define your tools:

<Tabs>
  <Tab title="Basic Tool">
    ```rust
    #[tool_router]
    impl MyServer {
        fn new() -> Self {
            Self {
                data: Arc::new(Mutex::new(HashMap::new())),
                tool_router: Self::tool_router(), // Generated by macro
            }
        }

        #[tool(description = "Store a key-value pair")]
        async fn store(&self, key: String, value: String) -> Result<String, ErrorData> {
            let mut data = self.data.lock().await;
            data.insert(key.clone(), value);
            Ok(format!("Stored: {}", key))
        }
    }
    ```
  </Tab>

  <Tab title="With Optional Parameters">
    ```rust
    #[tool(description = "Get value with optional default")]
    async fn get(&self, key: String, default: Option<String>) -> Result<String, ErrorData> {
        let data = self.data.lock().await;
        Ok(data.get(&key)
            .cloned()
            .or(default)
            .ok_or_else(|| ErrorData::not_found("Key not found"))?)
    }
    ```
  </Tab>

  <Tab title="With Structured Return">
    ```rust
    use serde::{Serialize, Deserialize};
    use schemars::JsonSchema;

    #[derive(Serialize, Deserialize, JsonSchema)]
    struct StoreResult {
        key: String,
        success: bool,
        previous_value: Option<String>,
    }

    #[tool(description = "Store with detailed result")]
    async fn store_detailed(&self, key: String, value: String)
        -> Result<StoreResult, ErrorData>
    {
        let mut data = self.data.lock().await;
        let previous = data.insert(key.clone(), value);

        Ok(StoreResult {
            key,
            success: true,
            previous_value: previous,
        })
    }
    ```
  </Tab>

  <Tab title="With Context Extractors">
    ```rust
    use vulcan::service::RequestContext;
    use vulcan::RoleServer;

    #[tool(description = "Get request metadata")]
    async fn get_meta(&self, context: RequestContext<RoleServer>)
        -> Result<String, ErrorData>
    {
        Ok(format!("Request ID: {}", context.correlation_id))
    }
    ```
  </Tab>
</Tabs>

<Tip>
**Tool functions MUST be `async fn`**, even if they don't use `await`. This is required by the macro system.
</Tip>

### 4. Implement ServerHandler

Use the `#[tool_handler]` macro to auto-implement `ServerHandler`:

```rust
use vulcan::{tool_handler, ServerHandler, model::*};

#[tool_handler]
impl ServerHandler for MyServer {
    fn get_info(&self) -> ServerInfo {
        ServerInfo {
            protocol_version: ProtocolVersion::V_2024_11_05,
            capabilities: ServerCapabilities::builder()
                .enable_tools()
                .build(),
            server_info: Implementation {
                name: "my-server".to_string(),
                title: Some("My MCP Server".to_string()),
                version: "1.0.0".to_string(),
                icons: None,
                website_url: None,
            },
            instructions: Some(
                "A simple key-value store server.".to_string()
            ),
        }
    }
}
```

<Note>
The `#[tool_handler]` macro automatically implements:
- `list_tools()` - returns all registered tools
- `call_tool()` - dispatches to the correct method

You only need to implement `get_info()`!
</Note>

### 5. Choose a Transport

Vulcan supports multiple transports. For Claude Desktop, use stdio:

<CodeGroup>

```rust Stdio (Claude Desktop)
use tokio::io::{stdin, stdout};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    use vulcan::service::ServiceExt;

    let server = MyServer::new();
    server.serve((stdin(), stdout())).await?;
    Ok(())
}
```

```rust HTTP (Web)
use vulcan::transport::StreamableHttpService;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let server = MyServer::new();
    let http_service = StreamableHttpService::new(server, Default::default());

    // Use with axum, actix-web, etc.
    Ok(())
}
```

```rust SSE (Server-Sent Events)
use vulcan::transport::SseServer;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let server = MyServer::new();
    let sse_server = SseServer::new(server);

    // Integrate with your web framework
    Ok(())
}
```

</CodeGroup>

### 6. Integrate with Claude Desktop

Add your server to Claude Desktop's configuration:

<Tabs>
  <Tab title="macOS">
    ```json ~/Library/Application Support/Claude/claude_desktop_config.json
    {
      "mcpServers": {
        "my-server": {
          "command": "/absolute/path/to/target/release/my-mcp-server"
        }
      }
    }
    ```
  </Tab>

  <Tab title="Windows">
    ```json %APPDATA%\Claude\claude_desktop_config.json
    {
      "mcpServers": {
        "my-server": {
          "command": "C:\\absolute\\path\\to\\target\\release\\my-mcp-server.exe"
        }
      }
    }
    ```
  </Tab>

  <Tab title="Linux">
    ```json ~/.config/Claude/claude_desktop_config.json
    {
      "mcpServers": {
        "my-server": {
          "command": "/absolute/path/to/target/release/my-mcp-server"
        }
      }
    }
    ```
  </Tab>
</Tabs>

Build and restart Claude Desktop:

```bash
cargo build --release
```

## Advanced Features

### Adding Middleware

Add logging, metrics, retry, and timeout with middleware:

```rust
use vulcan::adapters::*;
use vulcan::ports::MiddlewareChain;
use std::sync::Arc;
use std::time::Duration;

let mut chain = MiddlewareChain::new();
chain.add(Arc::new(LoggingMiddleware::new()));
chain.add(Arc::new(MetricsMiddleware::new()));
chain.add(Arc::new(TimeoutMiddleware::new(Duration::from_secs(30))));
chain.add(Arc::new(RetryMiddleware::new(3)));
```

<Tip>
See the [Middleware Guide](/concepts/middleware) for complete middleware documentation.
</Tip>

### Custom Error Types

Add ergonomic error handling for your domain errors:

```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum MyError {
    #[error("Database error: {0}")]
    Database(String),
    #[error("Validation error: {0}")]
    Validation(String),
}

impl From<MyError> for ErrorData {
    fn from(error: MyError) -> Self {
        match error {
            MyError::Database(msg) => ErrorData::internal(msg),
            MyError::Validation(msg) => ErrorData::invalid_input(msg),
        }
    }
}

// Now use .await? everywhere!
#[tool(description = "Query database")]
async fn query(&self, id: String) -> Result<Data, ErrorData> {
    let data = self.db.get(&id).await?; // Auto-converts MyError!
    Ok(data)
}
```

### State Management

For complex state, use proper synchronization:

<CodeGroup>

```rust Simple Mutex
use tokio::sync::Mutex;

#[derive(Clone)]
struct MyServer {
    state: Arc<Mutex<HashMap<String, String>>>,
    tool_router: ToolRouter<Self>,
}
```

```rust RwLock (Read-Heavy)
use tokio::sync::RwLock;

#[derive(Clone)]
struct MyServer {
    state: Arc<RwLock<HashMap<String, String>>>,
    tool_router: ToolRouter<Self>,
}

#[tool(description = "Read value")]
async fn read(&self, key: String) -> Result<Option<String>, ErrorData> {
    let state = self.state.read().await;
    Ok(state.get(&key).cloned())
}
```

```rust DashMap (Lock-Free)
use dashmap::DashMap;

#[derive(Clone)]
struct MyServer {
    state: Arc<DashMap<String, String>>,
    tool_router: ToolRouter<Self>,
}

#[tool(description = "Store value")]
async fn store(&self, key: String, value: String) -> Result<(), ErrorData> {
    self.state.insert(key, value);
    Ok(())
}
```

</CodeGroup>

## Best Practices

<AccordionGroup>
  <Accordion title="Keep Tools Focused">
    Each tool should do **one thing well**:

    ```rust
    // ✅ Good - focused tools
    #[tool(description = "Create user")]
    async fn create_user(&self, name: String) -> Result<User, ErrorData> { }

    #[tool(description = "Delete user")]
    async fn delete_user(&self, id: i64) -> Result<(), ErrorData> { }

    // ❌ Bad - too many responsibilities
    #[tool(description = "User operations")]
    async fn user_ops(&self, action: String, ...) -> Result<(), ErrorData> {
        match action.as_str() {
            "create" => { /* ... */ },
            "delete" => { /* ... */ },
            _ => Err(ErrorData::invalid_input("Unknown action")),
        }
    }
    ```
  </Accordion>

  <Accordion title="Write Clear Descriptions">
    Tool descriptions should be **actionable and specific**:

    ```rust
    // ✅ Good - clear and specific
    #[tool(description = "Search the product database for items matching the query. \
                          Returns up to 10 results sorted by relevance.")]
    async fn search_products(&self, query: String) -> Result<Vec<Product>, ErrorData> { }

    // ❌ Bad - vague
    #[tool(description = "Search")]
    async fn search(&self, q: String) -> Result<Vec<String>, ErrorData> { }
    ```
  </Accordion>

  <Accordion title="Use Typed Parameters">
    Avoid `serde_json::Value` - use concrete types:

    ```rust
    use serde::{Deserialize, Serialize};
    use schemars::JsonSchema;

    #[derive(Deserialize, JsonSchema)]
    struct CreateUserParams {
        name: String,
        email: String,
        age: Option<i32>,
    }

    // ✅ Good - typed parameters
    #[tool(description = "Create user")]
    async fn create_user(&self, params: CreateUserParams) -> Result<User, ErrorData> {
        // Compile-time safety!
    }

    // ❌ Bad - untyped
    #[tool(description = "Create user")]
    async fn create_user(&self, params: serde_json::Value) -> Result<User, ErrorData> {
        // Runtime errors waiting to happen
    }
    ```
  </Accordion>

  <Accordion title="Handle Errors Gracefully">
    Return descriptive errors:

    ```rust
    #[tool(description = "Get user")]
    async fn get_user(&self, id: i64) -> Result<User, ErrorData> {
        self.db.get_user(id).await
            .ok_or_else(|| ErrorData::not_found(format!("User {} not found", id)))
    }
    ```
  </Accordion>
</AccordionGroup>

## Common Patterns

### Request-Response Pattern

```rust
#[tool(description = "Echo message")]
async fn echo(&self, message: String) -> Result<String, ErrorData> {
    Ok(message)
}
```

### Stateful Operations

```rust
#[tool(description = "Add to cart")]
async fn add_to_cart(&self, item: String) -> Result<Cart, ErrorData> {
    let mut cart = self.cart.lock().await;
    cart.items.push(item);
    Ok(cart.clone())
}
```

### Async I/O Operations

```rust
#[tool(description = "Fetch URL")]
async fn fetch(&self, url: String) -> Result<String, ErrorData> {
    let response = reqwest::get(&url).await?;
    let text = response.text().await?;
    Ok(text)
}
```

### Database Operations

```rust
#[tool(description = "Query database")]
async fn query(&self, sql: String) -> Result<Vec<Row>, ErrorData> {
    let rows = sqlx::query(&sql)
        .fetch_all(&self.pool)
        .await?;
    Ok(rows)
}
```

## Troubleshooting

<Warning>
**Tool functions must be async**

All `#[tool]` functions must use `async fn`, even if they don't await:

```rust
// ❌ Wrong
#[tool(description = "Add")]
fn add(&self, a: i32, b: i32) -> Result<i32, ErrorData> { }

// ✅ Correct
#[tool(description = "Add")]
async fn add(&self, a: i32, b: i32) -> Result<i32, ErrorData> { }
```
</Warning>

<Tip>
See the [Troubleshooting Guide](/troubleshooting/overview) for complete error solutions.
</Tip>

## Next Steps

<CardGroup cols={2}>
  <Card title="Building a Client" icon="laptop-code" href="/guides/building-client">
    Learn how to build MCP clients
  </Card>
  <Card title="Error Handling" icon="triangle-exclamation" href="/guides/error-handling">
    Master error handling patterns
  </Card>
  <Card title="Testing" icon="vial" href="/guides/testing">
    Test your MCP servers
  </Card>
  <Card title="Middleware" icon="layer-group" href="/concepts/middleware">
    Add observability and retry logic
  </Card>
</CardGroup>
